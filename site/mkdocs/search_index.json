{
    "docs": [
        {
            "location": "/", 
            "text": "Code\n\n\n\n\nAny fool can write code that a computer can understand. Good programmers write code that humans can understand.\n- Martin Fowler\n\n\n\n\n\n\n\nLatest Posts\n\n\n(01/06/2017) \nHow to make a good question (and \"almost\" answer it)?\n\n\n(20/11/2016) \nHow to learn to code?\n\n\n(15/10/2016) \nCode Principles\n\n\n(20/09/2016) \nProgramming Paradigms\n\n\n(18/08/2016) \nWhat is testing?\n\n\n(16/07/2016) \nHow to log your program?\n\n\n(04/05/2016) \nFunctional Programming\n\n\n(02/05/2016) \nParallel Programming\n\n\n(09/02/2016) \nWhat is IDE\n\n\nBooks", 
            "title": "Home"
        }, 
        {
            "location": "/#code", 
            "text": "Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\n- Martin Fowler", 
            "title": "Code"
        }, 
        {
            "location": "/#latest-posts", 
            "text": "(01/06/2017)  How to make a good question (and \"almost\" answer it)?  (20/11/2016)  How to learn to code?  (15/10/2016)  Code Principles  (20/09/2016)  Programming Paradigms  (18/08/2016)  What is testing?  (16/07/2016)  How to log your program?  (04/05/2016)  Functional Programming  (02/05/2016)  Parallel Programming  (09/02/2016)  What is IDE", 
            "title": "Latest Posts"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/outline/", 
            "text": "Code\n\n\n\n\nIt's inspired by \nThis is CS50 course from Harvard University\n, \nProgramming for Everybody (Getting Started with Python) from coursera\n\n\n\n\nI will to do crazy and dummy things, I will rewrite article for basic languages (which tutorialpoints do very goods)\n\n\nEach language I will cover these concepts:\n\n\nTable of content\n\n\ncode/\n\u251c\u2500\u2500 1. introduction\n\u251c\u2500\u2500 2. syntax\n\u251c\u2500\u2500 3. data structure\n\u251c\u2500\u2500 4. oop\n\u251c\u2500\u2500 5. networking\n\u251c\u2500\u2500 6. os\n\u251c\u2500\u2500 7. parallel\n\u251c\u2500\u2500 8. event based\n\u251c\u2500\u2500 9. error handling\n\u251c\u2500\u2500 10. logging\n\u251c\u2500\u2500 11. configuration\n\u251c\u2500\u2500 12. documentation\n\u251c\u2500\u2500 13. test\n\u251c\u2500\u2500 14. ui\n\u251c\u2500\u2500 15. web\n\u251c\u2500\u2500 16. database\n\u251c\u2500\u2500 17. ide\n\u251c\u2500\u2500 18. package manager\n\u251c\u2500\u2500 19. build tool\n\u251c\u2500\u2500 20. make module\n\u2514\u2500\u2500 21. production (docker)\n\n\n\n\n1. Introduction\n\n\n\n\nInstallation (environment, IDE)\n\n\nHello world\n\n\nCourses\n\n\nResources\n\n\n\n\n2. Syntax\n\n\n\n\nvariables and expressions\n\n\nconditional\n\n\nloops and Iteration\n\n\nfunctions\n\n\ndefine, use\n\n\nparameters\n\n\nscope of variables\n\n\nanonymous functions\n\n\ncallbacks\n\n\nself-invoking functions\n, \ninner functions\n\n\nfunctions that return functions\n, \nfunctions that redefined themselves\n\n\nclosures\n\n\n\n\n\n\nnaming convention\n\n\ncomment convention\n\n\n\n\n3.Data Structure\n\n\n\n\nNumber\n\n\nString\n\n\nCollection\n\n\nDateTime\n\n\nBoolean\n\n\nObject\n\n\n\n\n4. OOP \n1\n\n\n\n\nClasses \n Objects \n\n\nInheritance\n\n\nEncapsulation\n\n\nAbstraction \n\n\nPolymorphism \n\n\n\n\nfor OOP Example: see \nPython: OOP\n\n\n5. Networking\n\n\n\n\nREST (example with chat app \nsender\n, \nreceiver\n, \nmessage\n)\n\n\n\n\nCode Learn\n\n\nCode.org\n\n\n\n\n\n\nStar Wars Characters Will Now Teach Your Kids To Code\n\n\n\n\nProjects \n1\n\n\n\n\nCreate\n\n\nGuess My Number Game\n\n\nCreate Analog Clock\n\n\nCreate Pong Game\n\n\nCreate flappy bird", 
            "title": "Outline"
        }, 
        {
            "location": "/outline/#code", 
            "text": "It's inspired by  This is CS50 course from Harvard University ,  Programming for Everybody (Getting Started with Python) from coursera   I will to do crazy and dummy things, I will rewrite article for basic languages (which tutorialpoints do very goods)  Each language I will cover these concepts:", 
            "title": "Code"
        }, 
        {
            "location": "/outline/#table-of-content", 
            "text": "code/\n\u251c\u2500\u2500 1. introduction\n\u251c\u2500\u2500 2. syntax\n\u251c\u2500\u2500 3. data structure\n\u251c\u2500\u2500 4. oop\n\u251c\u2500\u2500 5. networking\n\u251c\u2500\u2500 6. os\n\u251c\u2500\u2500 7. parallel\n\u251c\u2500\u2500 8. event based\n\u251c\u2500\u2500 9. error handling\n\u251c\u2500\u2500 10. logging\n\u251c\u2500\u2500 11. configuration\n\u251c\u2500\u2500 12. documentation\n\u251c\u2500\u2500 13. test\n\u251c\u2500\u2500 14. ui\n\u251c\u2500\u2500 15. web\n\u251c\u2500\u2500 16. database\n\u251c\u2500\u2500 17. ide\n\u251c\u2500\u2500 18. package manager\n\u251c\u2500\u2500 19. build tool\n\u251c\u2500\u2500 20. make module\n\u2514\u2500\u2500 21. production (docker)", 
            "title": "Table of content"
        }, 
        {
            "location": "/outline/#1-introduction", 
            "text": "Installation (environment, IDE)  Hello world  Courses  Resources", 
            "title": "1. Introduction"
        }, 
        {
            "location": "/outline/#2-syntax", 
            "text": "variables and expressions  conditional  loops and Iteration  functions  define, use  parameters  scope of variables  anonymous functions  callbacks  self-invoking functions ,  inner functions  functions that return functions ,  functions that redefined themselves  closures    naming convention  comment convention", 
            "title": "2. Syntax"
        }, 
        {
            "location": "/outline/#3data-structure", 
            "text": "Number  String  Collection  DateTime  Boolean  Object", 
            "title": "3.Data Structure"
        }, 
        {
            "location": "/outline/#4-oop-1", 
            "text": "Classes   Objects   Inheritance  Encapsulation  Abstraction   Polymorphism    for OOP Example: see  Python: OOP", 
            "title": "4. OOP 1"
        }, 
        {
            "location": "/outline/#5-networking", 
            "text": "REST (example with chat app  sender ,  receiver ,  message )", 
            "title": "5. Networking"
        }, 
        {
            "location": "/outline/#code-learn", 
            "text": "", 
            "title": "Code Learn"
        }, 
        {
            "location": "/outline/#codeorg", 
            "text": "Star Wars Characters Will Now Teach Your Kids To Code", 
            "title": "Code.org"
        }, 
        {
            "location": "/outline/#projects-1", 
            "text": "Create  Guess My Number Game  Create Analog Clock  Create Pong Game  Create flappy bird", 
            "title": "Projects 1"
        }, 
        {
            "location": "/principles/", 
            "text": "Programming Principles\n\n\nProgramming Principles \n1\n\n\n\nGeneric\n\n\n\n\n\nKISS (Keep It Simple Stupid)\n\n\nYAGNI\n\n\nDo The Simplest Thing That Could Possibly Work\n\n\nKeep Things DRY\n\n\nCode For The Maintainer\n\n\nAvoid Premature Optimization\n\n\n\n\n\nInter-Module/Class\n\n\n\n\n\nMinimise Coupling\n\n\nLaw of Demeter\n\n\nComposition Over Inheritance\n\n\nOrthogonality\n\n\n\n\n\nModule/Class\n\n\n\n\n\nMaximise Cohesion\n\n\nLiskov Substitution Principle\n\n\nOpen/Closed Principle\n\n\nSingle Responsibility Principle\n\n\nHide Implementation Details\n\n\nCurly's Law\n\n\n\n\n\nSoftware Quality Laws\n\n\n\nFirst Law of Software Quality\n\n\n\n\n\n\n\n\n\n\n\n\n\nhttp://webpro.github.io/programming-principles/", 
            "title": "Principles"
        }, 
        {
            "location": "/principles/#programming-principles", 
            "text": "", 
            "title": "Programming Principles"
        }, 
        {
            "location": "/ask/", 
            "text": "How to ask a question\n\n\n\n\nFocus on questions about an actual problem you have faced. Include details about what you have tried and exactly what you are trying to do.\n\n\n\n\nAsk about...\n\n\n\u2714 Specific programming problems\n\n\n\u2714  Software algorithms\n\n\n\u2714  Coding techniques\n\n\n\u2714  Software development tools\n\n\n\n\nNot all questions work well in our format. Avoid questions that are primarily opinion-based, or that are likely to generate discussion rather than answers.\n\n\n\n\nDon't ask about...\n\n\n\u2716 Questions you haven't tried to find an answer for (show your work!)\n\n\n\u2716 Product or service recommendations or comparisons\n\n\n\u2716 Requests for lists of things, polls, opinions, discussions, etc.\n\n\n\u2716 Anything not directly related to writing computer programs", 
            "title": "Ask a question"
        }, 
        {
            "location": "/ask/#how-to-ask-a-question", 
            "text": "Focus on questions about an actual problem you have faced. Include details about what you have tried and exactly what you are trying to do.   Ask about...  \u2714 Specific programming problems  \u2714  Software algorithms  \u2714  Coding techniques  \u2714  Software development tools   Not all questions work well in our format. Avoid questions that are primarily opinion-based, or that are likely to generate discussion rather than answers.   Don't ask about...  \u2716 Questions you haven't tried to find an answer for (show your work!)  \u2716 Product or service recommendations or comparisons  \u2716 Requests for lists of things, polls, opinions, discussions, etc.  \u2716 Anything not directly related to writing computer programs", 
            "title": "How to ask a question"
        }, 
        {
            "location": "/paradigms/", 
            "text": "Programming Paradigms\n\n\nMain paradigm approaches \n1\n\n\n1. Imperative\n\n\n\n\nDescription\n:\n\n\nComputation as statements that directly change a program state (datafields)\n\n\nMain Characteristics:\n\n\nDirect assignments\n, \ncommon data structures\n, \nglobal variables\n\n\nCritics:\n Edsger W. Dijkstra, Michael A. Jackson\n\n\nExamples:\n Assembly, C, C++, Java, PHP, Python\n\n\n2. Structured\n\n\nDescription\n:\n\n\nA style of imperative programming with more logical program structure\n\n\nMain Characteristics:\n\n\nStructograms\n, \nindentation\n, \neither no, or limited use of, goto statements\n\n\nExamples:\n C, C++, Java, Python\n\n\n3. Procedural\n\n\nDescription\n:\n\n\nDerived from structured programming, based on the concept of modular programming or the procedure call\n\n\nMain Characteristics:\n\n\nLocal variables\n, \nsequence\n, \nselection\n, \niteration\n, and \nmodularization\n\n\nExamples:\n C, C++, Lisp, PHP, Python\n\n\n4. Functional\n\n\n\n\nDescription\n:\n\n\nTreats computation as the evaluation of mathematical functions avoiding state and mutable data\n\n\nMain Characteristics:\n\n\nLambda calculus\n, \ncompositionality\n, \nformula\n, \nrecursion\n, \nreferential transparency\n, \nno side effects\n\n\nExamples:\n Clojure, Coffeescript, Elixir, Erlang, F#, Haskell, Lisp, Python, Scala, SequenceL, SML\n\n\n5. Event-driven including time driven\n\n\nDescription\n:\n\n\nProgram flow is determined mainly by events, such as mouse clicks or interrupts including timer\n\n\nMain Characteristics:\n\n\nMain loop\n, \nevent handlers\n, \nasynchronous processes\n\n\nExamples:\n Javascript, ActionScript, Visual Basic\n\n\n6. Object-oriented\n\n\nDescription\n:\n\n\nTreats datafields as objects manipulated through pre-defined methods only\n\n\nMain Characteristics:\n\n\nObjects\n, \nmethods\n, \nmessage passing\n, \ninformation hiding\n, \ndata abstraction\n, \nencapsulation\n, \npolymorphism\n, \ninheritance\n, \nserialization-marshalling\n\n\nExamples:\n Common Lisp, C++, C#, Eiffel, Java, PHP, Python, Ruby, Scala\n\n\n7. Declarative\n\n\nDescription\n:\n\n\nDefines computation logic without defining its detailed control flow\n\n\nMain Characteristics:\n\n\n4GLs\n, \nspreadsheets\n, \nreport program generators\n\n\nExamples:\n SQL, regular expressions, CSS, Prolog\n\n\n8. Automata-based programming\n\n\nDescription\n:\n\n\nTreats programs as a model of a finite state machine or any other formal automata\n\n\nMain Characteristics:\n\n\nState enumeration, control variable, state changes, isomorphism, state transition table\n\n\nExamples:\n \nAsmL\n\n\n\n\n\n\n\n\n\n\nComparison of programming paradigms", 
            "title": "Paradigms"
        }, 
        {
            "location": "/paradigms/#programming-paradigms", 
            "text": "", 
            "title": "Programming Paradigms"
        }, 
        {
            "location": "/paradigms/#main-paradigm-approaches-1", 
            "text": "", 
            "title": "Main paradigm approaches 1"
        }, 
        {
            "location": "/paradigms/#1-imperative", 
            "text": "Description :  Computation as statements that directly change a program state (datafields)  Main Characteristics:  Direct assignments ,  common data structures ,  global variables  Critics:  Edsger W. Dijkstra, Michael A. Jackson  Examples:  Assembly, C, C++, Java, PHP, Python", 
            "title": "1. Imperative"
        }, 
        {
            "location": "/paradigms/#2-structured", 
            "text": "Description :  A style of imperative programming with more logical program structure  Main Characteristics:  Structograms ,  indentation ,  either no, or limited use of, goto statements  Examples:  C, C++, Java, Python", 
            "title": "2. Structured"
        }, 
        {
            "location": "/paradigms/#3-procedural", 
            "text": "Description :  Derived from structured programming, based on the concept of modular programming or the procedure call  Main Characteristics:  Local variables ,  sequence ,  selection ,  iteration , and  modularization  Examples:  C, C++, Lisp, PHP, Python", 
            "title": "3. Procedural"
        }, 
        {
            "location": "/paradigms/#4-functional", 
            "text": "Description :  Treats computation as the evaluation of mathematical functions avoiding state and mutable data  Main Characteristics:  Lambda calculus ,  compositionality ,  formula ,  recursion ,  referential transparency ,  no side effects  Examples:  Clojure, Coffeescript, Elixir, Erlang, F#, Haskell, Lisp, Python, Scala, SequenceL, SML", 
            "title": "4. Functional"
        }, 
        {
            "location": "/paradigms/#5-event-driven-including-time-driven", 
            "text": "Description :  Program flow is determined mainly by events, such as mouse clicks or interrupts including timer  Main Characteristics:  Main loop ,  event handlers ,  asynchronous processes  Examples:  Javascript, ActionScript, Visual Basic", 
            "title": "5. Event-driven including time driven"
        }, 
        {
            "location": "/paradigms/#6-object-oriented", 
            "text": "Description :  Treats datafields as objects manipulated through pre-defined methods only  Main Characteristics:  Objects ,  methods ,  message passing ,  information hiding ,  data abstraction ,  encapsulation ,  polymorphism ,  inheritance ,  serialization-marshalling  Examples:  Common Lisp, C++, C#, Eiffel, Java, PHP, Python, Ruby, Scala", 
            "title": "6. Object-oriented"
        }, 
        {
            "location": "/paradigms/#7-declarative", 
            "text": "Description :  Defines computation logic without defining its detailed control flow  Main Characteristics:  4GLs ,  spreadsheets ,  report program generators  Examples:  SQL, regular expressions, CSS, Prolog", 
            "title": "7. Declarative"
        }, 
        {
            "location": "/paradigms/#8-automata-based-programming", 
            "text": "Description :  Treats programs as a model of a finite state machine or any other formal automata  Main Characteristics:  State enumeration, control variable, state changes, isomorphism, state transition table  Examples:   AsmL      Comparison of programming paradigms", 
            "title": "8. Automata-based programming"
        }, 
        {
            "location": "/testing/", 
            "text": "Testing\n\n\n\n\n1. Definition \n1\n \n2\n\n\nTest-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle:\n\n\n\n\n\n\nStep 1: First the developer writes an (initially failing) automated test case that defines a desired improvement or new function,\n\n\nStep 2: Then produces the minimum amount of code to pass that test,\n\n\nStep 3: Finally refactors the new code to acceptable standards.\n\n\n\n\nKent Beck, who is credited with having developed or 'rediscovered' the technique, stated in 2003 that TDD encourages simple designs and inspires confidence.\n\n\n2. Principles \n2\n\n\nKent Beck defines\n\n\n\n\nNever with a single line of code unless you have a failing automated test.\n\n\nEliminate duplication\n\n\n\n\nRed: (Automated test fail)\n\n\nGreen (Automated test pass because dev code has been written)\n\n\nRefactor (Eliminate duplication, Clean the code)\n\n\n3. Assertions \n Assert Framework\n\n\n\n  Assert that the expected results have occurred.\n\n\n\n\n[code lang=\"java\"]\n@Test\npublic void test() {\n    assertEquals(2, 1 + 1);\n}\n[/code]\n\n\n\n\n4. Test Runners \n3\n\n\n\n\n\n\nWhen testing a large real-world web app there may be tens or hundreds of test cases, and we certainly don't want to run each one manually. In such as scenario we need to use a test runner to find and execute the tests for us, and in this article we'll explore just that.\n\n\n\n\nA test runner provides the a good basis for a real testing framework. A test runner is designed to \nrun tests\n, \ntag tests\n with attributes (annotations), and \nprovide reporting\n and other features.\n\n\nIn general you break your tests up into 3 standard sections; \nsetUp()\n, \ntests\n, and \ntearDown()\n, typical for a test runner setup.\n\n\nThe setUp() and tearDown() methods are run automatically for every test, and contain respectively:\n\n\n\n\nThe setup steps you need to take before running the test, such as unlocking the screen and killing open apps.\n\n\nThe cooldown steps you need to run after the test, such as closing the Marionette session.\n\n\n\n\n5. Test Frameworks\n\n\n\n\n\n\nLanguage\n\n\nTest Frameworks\n\n\n\n\n\n\n\nC++/VisualStudio\n\n\nC++: Test\n\n\n\n\n\n\nWeb Service\n\n\nrest-assured\n\n\n\n\n\n\n\nWeb UI\n\n\nSeleniumHQ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest-driven development\n\n\n\n\n\n\nOverview on TDD (Test Driven Development) \n ATDD (Acceptance Test Driven Development)\n\n\n\n\n\n\nPart 5: Introducing a test runner", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#testing", 
            "text": "", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#1-definition-1-2", 
            "text": "Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle:    Step 1: First the developer writes an (initially failing) automated test case that defines a desired improvement or new function,  Step 2: Then produces the minimum amount of code to pass that test,  Step 3: Finally refactors the new code to acceptable standards.   Kent Beck, who is credited with having developed or 'rediscovered' the technique, stated in 2003 that TDD encourages simple designs and inspires confidence.", 
            "title": "1. Definition 1 2"
        }, 
        {
            "location": "/testing/#2-principles-2", 
            "text": "Kent Beck defines   Never with a single line of code unless you have a failing automated test.  Eliminate duplication   Red: (Automated test fail)  Green (Automated test pass because dev code has been written)  Refactor (Eliminate duplication, Clean the code)", 
            "title": "2. Principles 2"
        }, 
        {
            "location": "/testing/#3-assertions-assert-framework", 
            "text": "Assert that the expected results have occurred.  [code lang=\"java\"]\n@Test\npublic void test() {\n    assertEquals(2, 1 + 1);\n}\n[/code]", 
            "title": "3. Assertions &amp; Assert Framework"
        }, 
        {
            "location": "/testing/#4-test-runners-3", 
            "text": "When testing a large real-world web app there may be tens or hundreds of test cases, and we certainly don't want to run each one manually. In such as scenario we need to use a test runner to find and execute the tests for us, and in this article we'll explore just that.   A test runner provides the a good basis for a real testing framework. A test runner is designed to  run tests ,  tag tests  with attributes (annotations), and  provide reporting  and other features.  In general you break your tests up into 3 standard sections;  setUp() ,  tests , and  tearDown() , typical for a test runner setup.  The setUp() and tearDown() methods are run automatically for every test, and contain respectively:   The setup steps you need to take before running the test, such as unlocking the screen and killing open apps.  The cooldown steps you need to run after the test, such as closing the Marionette session.", 
            "title": "4. Test Runners 3"
        }, 
        {
            "location": "/testing/#5-test-frameworks", 
            "text": "Language  Test Frameworks    C++/VisualStudio  C++: Test    Web Service  rest-assured    Web UI  SeleniumHQ        Test-driven development    Overview on TDD (Test Driven Development)   ATDD (Acceptance Test Driven Development)    Part 5: Introducing a test runner", 
            "title": "5. Test Frameworks"
        }, 
        {
            "location": "/logging/", 
            "text": "Logging\n\n\n\n\nLogging \n1\n\n\nLogging is the process of recording application actions and state to a secondary interface.\n\n\nLogging System \n3\n\n\n\n\nLevels\n\n\n\n  \n\n    \nLevel\n\n    \nWhen it\u2019s used\n\n  \n\n  \n\n    \nDEBUG\n\n    \nDetailed information, typically of interest only when diagnosing problems.\n\n  \n\n  \n\n    \nINFO\n\n    \nConfirmation that things are working as expected.\n\n  \n\n  \n\n    \nWARNING\n\n    \nAn indication that something unexpected happened, or indicative of some problem in the near future (e.g. \u2018disk space low\u2019). The software is still working as expected.\n\n  \n\n  \n\n    \nERROR\n\n    \nDue to a more serious problem, the software has not been able to perform some function.\n\n  \n\n  \n\n    \nCRITICAL\n\n    \nA serious error, indicating that the program itself may be unable to continue running.\n\n  \n\n\n\n\n\nBest Practices \n2\n \n4\n \n5\n\n\n\n\nLogging should always be considered when handling an exception but should never take the place of a real handler.\n\n\nKeep all logging code in your production code. Have an ability to enable more/less detailed logging in production, preferably per subsystem and without restarting your program.\n\n\nMake logs easy to parse by grep and by eye. Stick to several common fields at the beginning of each line. Identify time, severity, and subsystem in every line. Clearly formulate the message. Make every log message easy to map to its source code line.\n\n\nIf an error happens, try to collect and log as much information as possible. It may take long but it's OK because normal processing has failed anyway. Not having to wait when the same condition happens in production with a debugger attached is priceless.\n\n\n\n\n\n\n\n\n\n\n\n\nThe Art of Logging\n\n\n\n\n\n\nFirst Rule Of Logging\n\n\n\n\n\n\nTaichung Python Logging\n\n\n\n\n\n\nLogging Best Practices\n\n\n\n\n\n\nWhat are some patterns and anti-patterns of application logging?", 
            "title": "Logging"
        }, 
        {
            "location": "/logging/#logging", 
            "text": "", 
            "title": "Logging"
        }, 
        {
            "location": "/logging/#logging-1", 
            "text": "Logging is the process of recording application actions and state to a secondary interface.", 
            "title": "Logging 1"
        }, 
        {
            "location": "/logging/#logging-system-3", 
            "text": "", 
            "title": "Logging System 3"
        }, 
        {
            "location": "/logging/#levels", 
            "text": "Level \n     When it\u2019s used \n   \n   \n     DEBUG \n     Detailed information, typically of interest only when diagnosing problems. \n   \n   \n     INFO \n     Confirmation that things are working as expected. \n   \n   \n     WARNING \n     An indication that something unexpected happened, or indicative of some problem in the near future (e.g. \u2018disk space low\u2019). The software is still working as expected. \n   \n   \n     ERROR \n     Due to a more serious problem, the software has not been able to perform some function. \n   \n   \n     CRITICAL \n     A serious error, indicating that the program itself may be unable to continue running.", 
            "title": "Levels"
        }, 
        {
            "location": "/logging/#best-practices-2-4-5", 
            "text": "Logging should always be considered when handling an exception but should never take the place of a real handler.  Keep all logging code in your production code. Have an ability to enable more/less detailed logging in production, preferably per subsystem and without restarting your program.  Make logs easy to parse by grep and by eye. Stick to several common fields at the beginning of each line. Identify time, severity, and subsystem in every line. Clearly formulate the message. Make every log message easy to map to its source code line.  If an error happens, try to collect and log as much information as possible. It may take long but it's OK because normal processing has failed anyway. Not having to wait when the same condition happens in production with a debugger attached is priceless.       The Art of Logging    First Rule Of Logging    Taichung Python Logging    Logging Best Practices    What are some patterns and anti-patterns of application logging?", 
            "title": "Best Practices 2 4 5"
        }, 
        {
            "location": "/functional/", 
            "text": "Functional\n\n\nWithout mutable variables, assignment, conditional\n\n\nAdvantages \n1\n\n\n\n\nMost functional languages provide a nice, protected environment, somewhat like JavaLanguage. It's good to be able to catch exceptions instead of having CoreDumps in stability-critical applications.\n\n\nFP encourages safe ways of programming. I've never seen an OffByOne mistake in a functional program, for example... I've seen one. Adding two lengths to get an index but one of them was zero-indexed. Easy to discover though. -- AnonymousDonor\n\n\nFunctional programs tend to be much more terse than their ImperativeLanguage counterparts. Often this leads to enhanced programmer productivity.\n\n\nFP encourages quick prototyping. As such, I think it is the best software design paradigm for ExtremeProgrammers... but what do I know.\n\n\nFP is modular in the dimension of functionality, where ObjectOrientedProgramming is modular in the dimension of different components.\n\n\nGeneric routines (also provided by CeePlusPlus) with easy syntax. ParametricPolymorphism\n\n\nThe ability to have your cake and eat it. Imagine you have a complex OO system processing messages - every component might make state changes depending on the message and then forward the message to some objects it has links to. Wouldn't it be just too cool to be able to easily roll back every change if some object deep in the call hierarchy decided the message is flawed? How about having a history of different states?\n\n\nMany housekeeping tasks made for you: deconstructing data structures (PatternMatching), storing variable bindings (LexicalScope with closures), strong typing (TypeInference), * GarbageCollection, storage allocation, whether to use boxed (pointer-to-value) or unboxed (value directly) representation...\n\n\nSafe multithreading! Immutable data structures are not subject to data race conditions, and consequently don't have to be protected by locks. If you are always allocating new objects, rather than destructively manipulating existing ones, the locking can be hidden in the allocation and GarbageCollection system.\n\n\n\n\n\n\n\n\n\n\n\n\nAdvantages Of Functional Programming", 
            "title": "Functional"
        }, 
        {
            "location": "/functional/#functional", 
            "text": "Without mutable variables, assignment, conditional", 
            "title": "Functional"
        }, 
        {
            "location": "/functional/#advantages-1", 
            "text": "Most functional languages provide a nice, protected environment, somewhat like JavaLanguage. It's good to be able to catch exceptions instead of having CoreDumps in stability-critical applications.  FP encourages safe ways of programming. I've never seen an OffByOne mistake in a functional program, for example... I've seen one. Adding two lengths to get an index but one of them was zero-indexed. Easy to discover though. -- AnonymousDonor  Functional programs tend to be much more terse than their ImperativeLanguage counterparts. Often this leads to enhanced programmer productivity.  FP encourages quick prototyping. As such, I think it is the best software design paradigm for ExtremeProgrammers... but what do I know.  FP is modular in the dimension of functionality, where ObjectOrientedProgramming is modular in the dimension of different components.  Generic routines (also provided by CeePlusPlus) with easy syntax. ParametricPolymorphism  The ability to have your cake and eat it. Imagine you have a complex OO system processing messages - every component might make state changes depending on the message and then forward the message to some objects it has links to. Wouldn't it be just too cool to be able to easily roll back every change if some object deep in the call hierarchy decided the message is flawed? How about having a history of different states?  Many housekeeping tasks made for you: deconstructing data structures (PatternMatching), storing variable bindings (LexicalScope with closures), strong typing (TypeInference), * GarbageCollection, storage allocation, whether to use boxed (pointer-to-value) or unboxed (value directly) representation...  Safe multithreading! Immutable data structures are not subject to data race conditions, and consequently don't have to be protected by locks. If you are always allocating new objects, rather than destructively manipulating existing ones, the locking can be hidden in the allocation and GarbageCollection system.       Advantages Of Functional Programming", 
            "title": "Advantages 1"
        }, 
        {
            "location": "/parallel/", 
            "text": "Paralell/Concurrency Programming\n\n\n1. Callback Pattern \n2\n\n\nCallback functions are derived from a programming paradigm known as functional programming. At a fundamental level, functional programming specifies the use of functions as arguments. Functional programming was\u2014and still is, though to a much lesser extent today\u2014seen as an esoteric technique of specially trained, master programmers.\n\n\nFortunately, the techniques of functional programming have been elucidated so that mere mortals like you and me can understand and use them with ease. One of the chief techniques in functional programming happens to be callback functions. As you will read shortly, implementing callback functions is as easy as passing regular variables as arguments. This technique is so simple that I wonder why it is mostly covered in advanced JavaScript topics.\n\n\n[code lang=\"javascript\"]\nfunction getN(){\n    return 10;\n}\n\n\nvar n = getN();\n\n\nfunction getAsyncN(callback){\n    setTimeout(function(){\n        callback(10);\n    }, 1000);\n}\n\n\nfunction afterGetAsyncN(result){\n    var n = 10;\n    console.log(n);\n}\n\n\ngetAsyncN(afterGetAsyncN);\n[/code]\n\n\n2. Promise Pattern \n1\n \n3\n\n\nWhat is a promise?\n\n\nThe core idea behind promises is that \na promise\n represents \nthe result of an asynchronous operation\n.\n\n\nA promise is in one of three different states:\n\n\n\n\npending - The initial state of a promise.\n\n\nfulfilled - The state of a promise representing a successful operation.\n\n\nrejected - The state of a promise representing a failed operation.\n\n\n\n\nOnce a promise is fulfilled or rejected, it is immutable (i.e. it can never change again).\n\n\n[code lang=\"javascript\"]\nfunction aPromise(message){\n    return new Promise(function(fulfill, reject){\n        if(message == \"success\"){\n            fulfill(\"it is a success Promise\");\n        }\n        if(message == \"fail\"){\n            reject(\"it is a fail Promise\");\n        }\n    });\n}\n[/code]\n\n\nUsage:\n\n\n[code lang=\"javascript\"]\naPromise(\"success\").then(function(successMessage){\n  console.log(successMessage)\n}, function(failMessage){\n  console.log(failMessage)\n})\n// it is a success Promise\n[/code]\n\n\n[code lang=\"javascript\"]\naPromise(\"fail\").then(function(successMessage){\n  console.log(successMessage)\n}, function(failMessage){\n  console.log(failMessage)\n})\n// it is a fail Promise\n[/code]\n\n\n\n\n\n\n\n\n\n\nPromise Paterns: \nhttps://www.promisejs.org/patterns/\n\n\n\n\n\n\nUnderstand JavaScript Callback Functions and Use Them\n\n\n\n\n\n\nPromise, Javascript", 
            "title": "Parallel"
        }, 
        {
            "location": "/parallel/#paralellconcurrency-programming", 
            "text": "", 
            "title": "Paralell/Concurrency Programming"
        }, 
        {
            "location": "/parallel/#1-callback-pattern-2", 
            "text": "Callback functions are derived from a programming paradigm known as functional programming. At a fundamental level, functional programming specifies the use of functions as arguments. Functional programming was\u2014and still is, though to a much lesser extent today\u2014seen as an esoteric technique of specially trained, master programmers.  Fortunately, the techniques of functional programming have been elucidated so that mere mortals like you and me can understand and use them with ease. One of the chief techniques in functional programming happens to be callback functions. As you will read shortly, implementing callback functions is as easy as passing regular variables as arguments. This technique is so simple that I wonder why it is mostly covered in advanced JavaScript topics.  [code lang=\"javascript\"]\nfunction getN(){\n    return 10;\n}  var n = getN();  function getAsyncN(callback){\n    setTimeout(function(){\n        callback(10);\n    }, 1000);\n}  function afterGetAsyncN(result){\n    var n = 10;\n    console.log(n);\n}  getAsyncN(afterGetAsyncN);\n[/code]", 
            "title": "1. Callback Pattern 2"
        }, 
        {
            "location": "/parallel/#2-promise-pattern-1-3", 
            "text": "", 
            "title": "2. Promise Pattern 1 3"
        }, 
        {
            "location": "/parallel/#what-is-a-promise", 
            "text": "The core idea behind promises is that  a promise  represents  the result of an asynchronous operation .  A promise is in one of three different states:   pending - The initial state of a promise.  fulfilled - The state of a promise representing a successful operation.  rejected - The state of a promise representing a failed operation.   Once a promise is fulfilled or rejected, it is immutable (i.e. it can never change again).  [code lang=\"javascript\"]\nfunction aPromise(message){\n    return new Promise(function(fulfill, reject){\n        if(message == \"success\"){\n            fulfill(\"it is a success Promise\");\n        }\n        if(message == \"fail\"){\n            reject(\"it is a fail Promise\");\n        }\n    });\n}\n[/code]  Usage:  [code lang=\"javascript\"]\naPromise(\"success\").then(function(successMessage){\n  console.log(successMessage)\n}, function(failMessage){\n  console.log(failMessage)\n})\n// it is a success Promise\n[/code]  [code lang=\"javascript\"]\naPromise(\"fail\").then(function(successMessage){\n  console.log(successMessage)\n}, function(failMessage){\n  console.log(failMessage)\n})\n// it is a fail Promise\n[/code]      Promise Paterns:  https://www.promisejs.org/patterns/    Understand JavaScript Callback Functions and Use Them    Promise, Javascript", 
            "title": "What is a promise?"
        }, 
        {
            "location": "/ide/", 
            "text": "IDE: Integrated Development Environment\n\n\nAn integrated development environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of a source code editor, build automation tools and a debugger. Most modern IDEs have intelligent code completion.\n\n\n1.\n Navigation\n\n\nWord Navigation\nLine Navigation\nFile Navigation\n\n\n2.\n Editing\n\n\nAuto Complete\nCode Complete\nMulticursor\nTemplate (Snippets)\n\n\n3.\n Formatting\n\n\nDebugging\n\n\nCustom Rendering for Object", 
            "title": "IDE"
        }, 
        {
            "location": "/ide/#ide-integrated-development-environment", 
            "text": "An integrated development environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of a source code editor, build automation tools and a debugger. Most modern IDEs have intelligent code completion.", 
            "title": "IDE: Integrated Development Environment"
        }, 
        {
            "location": "/ide/#1-navigation", 
            "text": "Word Navigation\nLine Navigation\nFile Navigation", 
            "title": "1. Navigation"
        }, 
        {
            "location": "/ide/#2-editing", 
            "text": "Auto Complete\nCode Complete\nMulticursor\nTemplate (Snippets)", 
            "title": "2. Editing"
        }, 
        {
            "location": "/ide/#3-formatting", 
            "text": "", 
            "title": "3. Formatting"
        }, 
        {
            "location": "/ide/#debugging", 
            "text": "Custom Rendering for Object", 
            "title": "Debugging"
        }
    ]
}