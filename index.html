<!DOCTYPE HTML>
<html ng-app>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="viewport" content="target-densitydpi=device-dpi"/>
  <meta name="HandheldFriendly" content="true"/>
  <link rel="canonical" href="http://underscorejs.org/"/>
  <link rel="shortcut icon" href="underscore-master/favicon.ico" type="image/x-icon"/>
  <title>Code</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="sidebar" class="interface">
  <a class="toc_title" href="#">
    Java <span class="version">(0.1)</span>
  </a>
  <ul class="toc_section">
    <li>&raquo; <a href="https://github.com/jashkenas/underscore">GitHub Repository</a></li>
    <li>&raquo; <a href="docs/underscore.html">Annotated Source</a></li>
    <li>&raquo; <a href="http://documentcloud.github.io/underscore-contrib/">Underscore-contrib</a></li>
  </ul>

  <input id="function_filter" placeholder="Filter" type="text" autofocus/>
  <ng-include src="'sections/collection/toc.html'"></ng-include>
  <ng-include src="'sections/time/toc.html'"></ng-include>


</div>

<div class="container">

  <div id="documentation">

    <h2 id="collections">Collection Functions (Arrays or Objects)</h2>

    <p id="each">
      <b class="header">each</b><code>_.each(list, iteratee, [context])</code>
      <span class="alias">Alias: <b>forEach</b></span>
      <br/>
      Iterates over a <b>list</b> of elements, yielding each in turn to an <b>iteratee</b>
      function. The <b>iteratee</b> is bound to the <b>context</b> object, if one is
      passed. Each invocation of <b>iteratee</b> is called with three arguments:
      <tt>(element, index, list)</tt>. If <b>list</b> is a JavaScript object, <b>iteratee</b>'s
      arguments will be <tt>(value, key, list)</tt>. Returns the <b>list</b> for chaining.
    </p>
      <pre>
_.each([1, 2, 3], alert);
=&gt; alerts each number in turn...
_.each({one: 1, two: 2, three: 3}, alert);
=&gt; alerts each number value in turn...</pre>

    <p>
      <i>
        Note: Collection functions work on arrays, objects, and
        array-like objects such as</i> <tt>arguments</tt>, <tt>NodeList</tt><i>
      and similar. But it works by duck-typing, so avoid passing objects with
      a numeric <tt>length</tt> property. It's also good to note that an
      <tt>each</tt> loop cannot be broken out of â€” to break, use <b>_.find</b>
      instead.
    </i>
    </p>

    <p id="map">
      <b class="header">map</b><code>_.map(list, iteratee, [context])</code>
      <span class="alias">Alias: <b>collect</b></span>
      <br/>
      Produces a new array of values by mapping each value in <b>list</b>
      through a transformation function (<b>iteratee</b>). The <tt>iteratee</tt>
      is passed three arguments: the <tt>value</tt>, then the <tt>index</tt>
      (or <tt>key</tt>) of the iteration, and finally a reference to the entire
      <tt>list</tt>.
    </p>
      <pre>
_.map([1, 2, 3], function(num){ return num * 3; });
=&gt; [3, 6, 9]
_.map({one: 1, two: 2, three: 3}, function(num, key){ return num * 3; });
=&gt; [3, 6, 9]
_.map([[1, 2], [3, 4]], _.first);
=&gt; [1, 3]</pre>

    <p id="reduce">
      <b class="header">reduce</b><code>_.reduce(list, iteratee, [memo], [context])</code>
      <span class="alias">Aliases: <b>inject</b>, <b>foldl</b></span>
      <br/>
      Also known as <b>inject</b> and <b>foldl</b>, reduce boils down a <b>list</b> of values into a single value.
      <b>Memo</b> is the initial state of the reduction, and each successive step of it should be returned by
      <b>iteratee</b>. The iteratee is passed four arguments: the <tt>memo</tt>, then the <tt>value</tt> and
      <tt>index</tt> (or key) of the iteration, and finally a reference to the entire <tt>list</tt>.
    </p>

    <p>
      If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element
      of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next
      element in the list.
    </p>
      <pre>
var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);
=&gt; 6
</pre>

    <p id="reduceRight">
      <b class="header">reduceRight</b><code>_.reduceRight(list, iteratee, memo, [context])</code>
      <span class="alias">Alias: <b>foldr</b></span>
      <br/>
      The right-associative version of <b>reduce</b>. <b>Foldr</b>
      is not as useful in JavaScript as it would be in a language with lazy
      evaluation.
    </p>
      <pre>
var list = [[0, 1], [2, 3], [4, 5]];
var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
=&gt; [4, 5, 2, 3, 0, 1]
</pre>

    <p id="find">
      <b class="header">find</b><code>_.find(list, predicate, [context])</code>
      <span class="alias">Alias: <b>detect</b></span>
      <br/>
      Looks through each value in the <b>list</b>, returning the first one that
      passes a truth test (<b>predicate</b>), or <tt>undefined</tt> if no value
      passes the test. The function returns as
      soon as it finds an acceptable element, and doesn't traverse the
      entire list.
    </p>
      <pre>
var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; 2
</pre>

    <p id="filter">
      <b class="header">filter</b><code>_.filter(list, predicate, [context])</code>
      <span class="alias">Alias: <b>select</b></span>
      <br/>
      Looks through each value in the <b>list</b>, returning an array of all
      the values that pass a truth test (<b>predicate</b>).
    </p>
      <pre>
var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; [2, 4, 6]
</pre>

    <p id="where">
      <b class="header">where</b><code>_.where(list, properties)</code>
      <br/>
      Looks through each value in the <b>list</b>, returning an array of all
      the values that contain all of the key-value pairs listed in <b>properties</b>.
    </p>
      <pre>
_.where(listOfPlays, {author: "Shakespeare", year: 1611});
=&gt; [{title: "Cymbeline", author: "Shakespeare", year: 1611},
    {title: "The Tempest", author: "Shakespeare", year: 1611}]
</pre>

    <p id="findWhere">
      <b class="header">findWhere</b><code>_.findWhere(list, properties)</code>
      <br/>
      Looks through the <b>list</b> and returns the <i>first</i> value that matches
      all of the key-value pairs listed in <b>properties</b>.
    </p>

    <p>
      If no match is found, or if <b>list</b> is empty, <i>undefined</i> will be
      returned.
    </p>
      <pre>
_.findWhere(publicServicePulitzers, {newsroom: "The New York Times"});
=&gt; {year: 1918, newsroom: "The New York Times",
  reason: "For its public service in publishing in full so many official reports,
  documents and speeches by European statesmen relating to the progress and
  conduct of the war."}
</pre>

    <p id="reject">
      <b class="header">reject</b><code>_.reject(list, predicate, [context])</code>
      <br/>
      Returns the values in <b>list</b> without the elements that the truth
      test (<b>predicate</b>) passes. The opposite of <b>filter</b>.
    </p>
      <pre>
var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; [1, 3, 5]
</pre>

    <p id="every">
      <b class="header">every</b><code>_.every(list, [predicate], [context])</code>
      <span class="alias">Alias: <b>all</b></span>
      <br/>
      Returns <i>true</i> if all of the values in the <b>list</b> pass the
      <b>predicate</b> truth test. Short-circuits and stops traversing the list
      if a false element is found.
    </p>
      <pre>
_.every([2, 4, 5], function(num) { return num % 2 == 0; });
=&gt; false
</pre>

    <p id="some">
      <b class="header">some</b><code>_.some(list, [predicate], [context])</code>
      <span class="alias">Alias: <b>any</b></span>
      <br/>
      Returns <i>true</i> if any of the values in the <b>list</b> pass the
      <b>predicate</b> truth test. Short-circuits and stops traversing the list
      if a true element is found.
    </p>
      <pre>
_.some([null, 0, 'yes', false]);
=&gt; true
</pre>

    <p id="contains">
      <b class="header">contains</b><code>_.contains(list, value, [fromIndex])</code>
      <span class="alias">Alias: <b>includes</b></span>
      <br/>
      Returns <i>true</i> if the <b>value</b> is present in the <b>list</b>.
      Uses <b>indexOf</b> internally, if <b>list</b> is an Array.
      Use <b>fromIndex</b> to start your search at a given index.
    </p>
      <pre>
_.contains([1, 2, 3], 3);
=&gt; true
</pre>

    <p id="invoke">
      <b class="header">invoke</b><code>_.invoke(list, methodName, *arguments)</code>
      <br/>
      Calls the method named by <b>methodName</b> on each value in the <b>list</b>.
      Any extra arguments passed to <b>invoke</b> will be forwarded on to the
      method invocation.
    </p>
      <pre>
_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
=&gt; [[1, 5, 7], [1, 2, 3]]
</pre>

    <p id="pluck">
      <b class="header">pluck</b><code>_.pluck(list, propertyName)</code>
      <br/>
      A convenient version of what is perhaps the most common use-case for
      <b>map</b>: extracting a list of property values.
    </p>
      <pre>
var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.pluck(stooges, 'name');
=&gt; ["moe", "larry", "curly"]
</pre>

    <p id="max">
      <b class="header">max</b><code>_.max(list, [iteratee], [context])</code>
      <br/>
      Returns the maximum value in <b>list</b>. If an <b>iteratee</b>
      function is provided, it will be used on each value to generate the
      criterion by which the value is ranked. <i>-Infinity</i> is returned
      if <b>list</b> is empty, so an <a href="#isEmpty">isEmpty</a> guard
      may be required.
    </p>
      <pre>
var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.max(stooges, function(stooge){ return stooge.age; });
=&gt; {name: 'curly', age: 60};
</pre>

    <p id="min">
      <b class="header">min</b><code>_.min(list, [iteratee], [context])</code>
      <br/>
      Returns the minimum value in <b>list</b>. If an <b>iteratee</b>
      function is provided, it will be used on each value to generate the
      criterion by which the value is ranked. <i>Infinity</i> is returned
      if <b>list</b> is empty, so an <a href="#isEmpty">isEmpty</a> guard
      may be required.
    </p>
      <pre>
var numbers = [10, 5, 100, 2, 1000];
_.min(numbers);
=&gt; 2
</pre>

    <p id="sortBy">
      <b class="header">sortBy</b><code>_.sortBy(list, iteratee, [context])</code>
      <br/>
      Returns a (stably) sorted copy of <b>list</b>, ranked in ascending
      order by the results of running each value through <b>iteratee</b>.
      iteratee may also be the string name of the property to sort by (eg.
      <tt>length</tt>).
    </p>
      <pre>
_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });
=&gt; [5, 4, 6, 3, 1, 2]

var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.sortBy(stooges, 'name');
=&gt; [{name: 'curly', age: 60}, {name: 'larry', age: 50}, {name: 'moe', age: 40}];
</pre>
    <p id="groupBy">
      <b class="header">groupBy</b><code>_.groupBy(list, iteratee, [context])</code>
      <br/>
      Splits a collection into sets, grouped by the result of running each
      value through <b>iteratee</b>. If <b>iteratee</b> is a string instead of
      a function, groups by the property named by <b>iteratee</b> on each of
      the values.
    </p>
      <pre>
_.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });
=&gt; {1: [1.3], 2: [2.1, 2.4]}

_.groupBy(['one', 'two', 'three'], 'length');
=&gt; {3: ["one", "two"], 5: ["three"]}
</pre>

    <p id="indexBy">
      <b class="header">indexBy</b><code>_.indexBy(list, iteratee, [context])</code>
      <br/>
      Given a <b>list</b>, and an <b>iteratee</b> function that returns a
      key for each element in the list (or a property name),
      returns an object with an index of each item.
      Just like <a href="#groupBy">groupBy</a>, but for when you know your
      keys are unique.
    </p>
      <pre>
var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.indexBy(stooges, 'age');
=&gt; {
  "40": {name: 'moe', age: 40},
  "50": {name: 'larry', age: 50},
  "60": {name: 'curly', age: 60}
}
</pre>

    <p id="countBy">
      <b class="header">countBy</b><code>_.countBy(list, iteratee, [context])</code>
      <br/>
      Sorts a list into groups and returns a count for the number of objects
      in each group.
      Similar to <tt>groupBy</tt>, but instead of returning a list of values,
      returns a count for the number of values in that group.
    </p>
      <pre>
_.countBy([1, 2, 3, 4, 5], function(num) {
  return num % 2 == 0 ? 'even': 'odd';
});
=&gt; {odd: 3, even: 2}
</pre>

    <p id="shuffle">
      <b class="header">shuffle</b><code>_.shuffle(list)</code>
      <br/>
      Returns a shuffled copy of the <b>list</b>, using a version of the
      <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a>.
    </p>
      <pre>
_.shuffle([1, 2, 3, 4, 5, 6]);
=&gt; [4, 1, 6, 3, 5, 2]
</pre>

    <p id="sample">
      <b class="header">sample</b><code>_.sample(list, [n])</code>
      <br/>
      Produce a random sample from the <b>list</b>. Pass a number to
      return <b>n</b> random elements from the list. Otherwise a single random
      item will be returned.
    </p>
      <pre>
_.sample([1, 2, 3, 4, 5, 6]);
=&gt; 4

_.sample([1, 2, 3, 4, 5, 6], 3);
=&gt; [1, 6, 2]
</pre>

    <p id="toArray">
      <b class="header">toArray</b><code>_.toArray(list)</code>
      <br/>
      Creates a real Array from the <b>list</b> (anything that can be
      iterated over). Useful for transmuting the <b>arguments</b> object.
    </p>
      <pre>
(function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
=&gt; [2, 3, 4]
</pre>

    <p id="size">
      <b class="header">size</b><code>_.size(list)</code>
      <br/>
      Return the number of values in the <b>list</b>.
    </p>
      <pre>
_.size({one: 1, two: 2, three: 3});
=&gt; 3
</pre>

    <p id="partition">
      <b class="header">partition</b><code>_.partition(array, predicate)</code>
      <br/>
      Split <b>array</b> into two arrays: one whose elements all satisfy
      <b>predicate</b> and one whose elements all do not satisfy <b>predicate</b>.
    </p>
      <pre>
_.partition([0, 1, 2, 3, 4, 5], isOdd);
=&gt; [[1, 3, 5], [0, 2, 4]]
</pre>

    <h2 id="arrays">Array Functions</h2>

    <p>
      <i>
        Note: All array functions will also work on the <b>arguments</b> object.
        However, Underscore functions are not designed to work on "sparse" arrays.
      </i>
    </p>

    <p id="first">
      <b class="header">first</b><code>_.first(array, [n])</code>
      <span class="alias">Aliases: <b>head</b>, <b>take</b></span>
      <br/>
      Returns the first element of an <b>array</b>. Passing <b>n</b> will
      return the first <b>n</b> elements of the array.
    </p>
      <pre>
_.first([5, 4, 3, 2, 1]);
=&gt; 5
</pre>

    <p id="initial">
      <b class="header">initial</b><code>_.initial(array, [n])</code>
      <br/>
      Returns everything but the last entry of the array. Especially useful on
      the arguments object. Pass <b>n</b> to exclude the last <b>n</b> elements
      from the result.
    </p>
      <pre>
_.initial([5, 4, 3, 2, 1]);
=&gt; [5, 4, 3, 2]
</pre>

    <p id="last">
      <b class="header">last</b><code>_.last(array, [n])</code>
      <br/>
      Returns the last element of an <b>array</b>. Passing <b>n</b> will return
      the last <b>n</b> elements of the array.
    </p>
      <pre>
_.last([5, 4, 3, 2, 1]);
=&gt; 1
</pre>

    <p id="rest">
      <b class="header">rest</b><code>_.rest(array, [index])</code>
      <span class="alias">Aliases: <b>tail</b>, <b>drop</b></span>
      <br/>
      Returns the <b>rest</b> of the elements in an array. Pass an <b>index</b>
      to return the values of the array from that index onward.
    </p>
      <pre>
_.rest([5, 4, 3, 2, 1]);
=&gt; [4, 3, 2, 1]
</pre>

    <p id="compact">
      <b class="header">compact</b><code>_.compact(array)</code>
      <br/>
      Returns a copy of the <b>array</b> with all falsy values removed.
      In JavaScript, <i>false</i>, <i>null</i>, <i>0</i>, <i>""</i>,
      <i>undefined</i> and <i>NaN</i> are all falsy.
    </p>
      <pre>
_.compact([0, 1, false, 2, '', 3]);
=&gt; [1, 2, 3]
</pre>

    <p id="flatten">
      <b class="header">flatten</b><code>_.flatten(array, [shallow])</code>
      <br/>
      Flattens a nested <b>array</b> (the nesting can be to any depth). If you
      pass <b>shallow</b>, the array will only be flattened a single level.
    </p>
      <pre>
_.flatten([1, [2], [3, [[4]]]]);
=&gt; [1, 2, 3, 4];

_.flatten([1, [2], [3, [[4]]]], true);
=&gt; [1, 2, 3, [[4]]];
</pre>

    <p id="without">
      <b class="header">without</b><code>_.without(array, *values)</code>
      <br/>
      Returns a copy of the <b>array</b> with all instances of the <b>values</b>
      removed.
    </p>
      <pre>
_.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
=&gt; [2, 3, 4]
</pre>

    <p id="union">
      <b class="header">union</b><code>_.union(*arrays)</code>
      <br/>
      Computes the union of the passed-in <b>arrays</b>: the list of unique items,
      in order, that are present in one or more of the <b>arrays</b>.
    </p>
      <pre>
_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
=&gt; [1, 2, 3, 101, 10]
</pre>

    <p id="intersection">
      <b class="header">intersection</b><code>_.intersection(*arrays)</code>
      <br/>
      Computes the list of values that are the intersection of all the <b>arrays</b>.
      Each value in the result is present in each of the <b>arrays</b>.
    </p>
      <pre>
_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
=&gt; [1, 2]
</pre>

    <p id="difference">
      <b class="header">difference</b><code>_.difference(array, *others)</code>
      <br/>
      Similar to <b>without</b>, but returns the values from <b>array</b> that
      are not present in the <b>other</b> arrays.
    </p>
      <pre>
_.difference([1, 2, 3, 4, 5], [5, 2, 10]);
=&gt; [1, 3, 4]
</pre>

    <p id="uniq">
      <b class="header">uniq</b><code>_.uniq(array, [isSorted], [iteratee])</code>
      <span class="alias">Alias: <b>unique</b></span>
      <br/>
      Produces a duplicate-free version of the <b>array</b>, using <i>===</i> to test
      object equality. In particular only the first occurence of each value is kept.
      If you know in advance that the <b>array</b> is sorted,
      passing <i>true</i> for <b>isSorted</b> will run a much faster algorithm.
      If you want to compute unique items based on a transformation, pass an
      <b>iteratee</b> function.
    </p>
      <pre>
_.uniq([1, 2, 1, 4, 1, 3]);
=&gt; [1, 2, 4, 3]
</pre>

    <p id="zip">
      <b class="header">zip</b><code>_.zip(*arrays)</code>
      <br/>
      Merges together the values of each of the <b>arrays</b> with the
      values at the corresponding position. Useful when you have separate
      data sources that are coordinated through matching array indexes.
      Use with <tt>apply</tt> to pass in an array of arrays.
      If you're working with a matrix of nested arrays, this can be used to
      transpose the matrix.
    </p>
      <pre>
_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]

</pre>

    <p id="unzip">
      <b class="header">unzip</b><code>_.unzip(array)</code>
      <br>
      The opposite of <a href="#zip">zip</a>. Given an <b>array</b> of arrays, returns a
      series of new arrays, the first of which contains all of the first elements
      in the input arrays, the second of which contains all of the second elements,
      and so on.
    </p>
      <pre>
_.unzip([["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]);
=&gt; [['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]]
</pre>

    <p id="object">
      <b class="header">object</b><code>_.object(list, [values])</code>
      <br/>
      Converts arrays into objects. Pass either a single list of
      <tt>[key, value]</tt> pairs, or a list of keys, and a list of values.
      If duplicate keys exist, the last value wins.
    </p>
      <pre>
_.object(['moe', 'larry', 'curly'], [30, 40, 50]);
=&gt; {moe: 30, larry: 40, curly: 50}

_.object([['moe', 30], ['larry', 40], ['curly', 50]]);
=&gt; {moe: 30, larry: 40, curly: 50}
</pre>

    <p id="indexOf">
      <b class="header">indexOf</b><code>_.indexOf(array, value, [isSorted])</code>
      <br/>
      Returns the index at which <b>value</b> can be found in the <b>array</b>,
      or <i>-1</i> if value is not present in the <b>array</b>. If you're working with a
      large array, and you know that the array is already sorted, pass <tt>true</tt>
      for <b>isSorted</b> to use a faster binary search ... or, pass a number as
      the third argument in order to look for the first matching value in the
      array after the given index.
    </p>
      <pre>
_.indexOf([1, 2, 3], 2);
=&gt; 1
</pre>

    <p id="lastIndexOf">
      <b class="header">lastIndexOf</b><code>_.lastIndexOf(array, value, [fromIndex])</code>
      <br/>
      Returns the index of the last occurrence of <b>value</b> in the <b>array</b>,
      or <i>-1</i> if value is not present. Pass <b>fromIndex</b> to start your search at a
      given index.
    </p>
      <pre>
_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
=&gt; 4
</pre>

    <p id="sortedIndex">
      <b class="header">sortedIndex</b><code>_.sortedIndex(list, value, [iteratee], [context])</code>
      <br/>
      Uses a binary search to determine the index at which the <b>value</b>
      <i>should</i> be inserted into the <b>list</b> in order to maintain the <b>list</b>'s
      sorted order. If an <b>iteratee</b> function is provided, it will be used to compute
      the sort ranking of each value, including the <b>value</b> you pass.
      The iteratee may also be the string name of the property to sort by (eg. <tt>length</tt>).
    </p>
      <pre>
_.sortedIndex([10, 20, 30, 40, 50], 35);
=&gt; 3

var stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];
_.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');
=&gt; 1
</pre>

    <p id="findIndex">
      <b class="header">findIndex</b><code>_.findIndex(array, predicate, [context])</code>
      <br/>
      Similar to <a href="#indexOf"><tt>_.indexOf</tt></a>, returns the first index
      where the <strong>predicate</strong> truth test passes; otherwise returns <i>-1</i>.
    </p>
      <pre>
_.findIndex([4, 6, 8, 12], isPrime);
=&gt; -1 // not found
_.findIndex([4, 6, 7, 12], isPrime);
=&gt; 2
</pre>

    <p id="findLastIndex">
      <b class="header">findLastIndex</b><code>_.findLastIndex(array, predicate, [context])</code>
      <br/>
      Like <a href="#findIndex"><tt>_.findIndex</tt></a> but iterates the array in reverse,
      returning the index closest to the end where the <strong>predicate</strong> truth test
      passes.
    </p>
      <pre>
var users = [{'id': 1, 'name': 'Bob', 'last': 'Brown'},
             {'id': 2, 'name': 'Ted', 'last': 'White'},
             {'id': 3, 'name': 'Frank', 'last': 'James'},
             {'id': 4, 'name': 'Ted', 'last': 'Jones'}];
_.findLastIndex(users, {
  name: 'Ted'
});
=&gt; 3
</pre>

    <p id="range">
      <b class="header">range</b><code>_.range([start], stop, [step])</code>
      <br/>
      A function to create flexibly-numbered lists of integers, handy for
      <tt>each</tt> and <tt>map</tt> loops. <b>start</b>, if omitted, defaults
      to <i>0</i>; <b>step</b> defaults to <i>1</i>. Returns a list of integers
      from <b>start</b> (inclusive) to <b>stop</b> (exclusive), incremented (or decremented) by <b>step</b>,
      exclusive. Note that ranges that <b>stop</b> before they <b>start</b>
      are considered to be zero-length instead of negative â€” if you'd like a
      negative range, use a negative <b>step</b>.
    </p>
      <pre>
_.range(10);
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
_.range(1, 11);
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
_.range(0, 30, 5);
=&gt; [0, 5, 10, 15, 20, 25]
_.range(0, -10, -1);
=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
_.range(0);
=&gt; []
</pre>

    <h2 id="functions">Function (uh, ahem) Functions</h2>

    <p id="bind">
      <b class="header">bind</b><code>_.bind(function, object, *arguments)</code>
      <br/>
      Bind a <b>function</b> to an <b>object</b>, meaning that whenever
      the function is called, the value of <i>this</i> will be the <b>object</b>.
      Optionally, pass <b>arguments</b> to the <b>function</b> to pre-fill them,
      also known as <b>partial application</b>. For partial application without
      context binding, use <a href="#partial">partial</a>.
    </p>
      <pre>
var func = function(greeting){ return greeting + ': ' + this.name };
func = _.bind(func, {name: 'moe'}, 'hi');
func();
=&gt; 'hi: moe'
</pre>

    <p id="bindAll">
      <b class="header">bindAll</b><code>_.bindAll(object, *methodNames)</code>
      <br/>
      Binds a number of methods on the <b>object</b>, specified by
      <b>methodNames</b>, to be run in the context of that object whenever they
      are invoked. Very handy for binding functions that are going to be used
      as event handlers, which would otherwise be invoked with a fairly useless
      <i>this</i>. <b>methodNames</b> are required.
    </p>
      <pre>
var buttonView = {
  label  : 'underscore',
  onClick: function(){ alert('clicked: ' + this.label); },
  onHover: function(){ console.log('hovering: ' + this.label); }
};
_.bindAll(buttonView, 'onClick', 'onHover');
// When the button is clicked, this.label will have the correct value.
jQuery('#underscore_button').on('click', buttonView.onClick);
</pre>

    <p id="partial">
      <b class="header">partial</b><code>_.partial(function, *arguments)</code>
      <br/>
      Partially apply a function by filling in any number of its <b>arguments</b>,
      <i>without</i> changing its dynamic <tt>this</tt> value. A close cousin
      of <a href="#bind">bind</a>. You may pass <tt>_</tt> in your list of
      <b>arguments</b> to specify an argument that should not be pre-filled, but
      left open to supply at call-time.
    </p>
      <pre>
var subtract = function(a, b) { return b - a; };
sub5 = _.partial(subtract, 5);
sub5(20);
=&gt; 15

// Using a placeholder
subFrom20 = _.partial(subtract, _, 20);
subFrom20(5);
=&gt; 15
</pre>

    <p id="memoize">
      <b class="header">memoize</b><code>_.memoize(function, [hashFunction])</code>
      <br/>
      Memoizes a given <b>function</b> by caching the computed result. Useful
      for speeding up slow-running computations. If passed an optional
      <b>hashFunction</b>, it will be used to compute the hash key for storing
      the result, based on the arguments to the original function. The default
      <b>hashFunction</b> just uses the first argument to the memoized function
      as the key. The cache of memoized values is available as the <tt>cache</tt>
      property on the returned function.
    </p>
      <pre>
var fibonacci = _.memoize(function(n) {
  return n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);
});
</pre>

    <p id="delay">
      <b class="header">delay</b><code>_.delay(function, wait, *arguments)</code>
      <br/>
      Much like <b>setTimeout</b>, invokes <b>function</b> after <b>wait</b>
      milliseconds. If you pass the optional <b>arguments</b>, they will be
      forwarded on to the <b>function</b> when it is invoked.
    </p>
      <pre>
var log = _.bind(console.log, console);
_.delay(log, 1000, 'logged later');
=&gt; 'logged later' // Appears after one second.
</pre>

    <p id="defer">
      <b class="header">defer</b><code>_.defer(function, *arguments)</code>
      <br/>
      Defers invoking the <b>function</b> until the current call stack has cleared,
      similar to using <b>setTimeout</b> with a delay of 0. Useful for performing
      expensive computations or HTML rendering in chunks without blocking the UI thread
      from updating. If you pass the optional <b>arguments</b>, they will be
      forwarded on to the <b>function</b> when it is invoked.
    </p>
      <pre>
_.defer(function(){ alert('deferred'); });
// Returns from the function before the alert runs.
</pre>

    <p id="throttle">
      <b class="header">throttle</b><code>_.throttle(function, wait, [options])</code>
      <br/>
      Creates and returns a new, throttled version of the passed function,
      that, when invoked repeatedly, will only actually call the original function
      at most once per every <b>wait</b>
      milliseconds. Useful for rate-limiting events that occur faster than you
      can keep up with.
    </p>

    <p>
      By default, <b>throttle</b> will execute the function as soon as you call it
      for the first time, and, if you call it again any number of times
      during the <b>wait</b> period, as soon as that period is over.
      If you'd like to disable the leading-edge
      call, pass <tt>{leading: false}</tt>, and if you'd like to disable the
      execution on the trailing-edge, pass <br/> <tt>{trailing: false}</tt>.
    </p>
      <pre>
var throttled = _.throttle(updatePosition, 100);
$(window).scroll(throttled);
</pre>

    <p id="debounce">
      <b class="header">debounce</b><code>_.debounce(function, wait, [immediate])</code>
      <br/>
      Creates and returns a new debounced version of the passed function which
      will postpone its execution until after
      <b>wait</b> milliseconds have elapsed since the last time it
      was invoked. Useful for implementing behavior that should only happen
      <i>after</i> the input has stopped arriving. For example: rendering a
      preview of a Markdown comment, recalculating a layout after the window
      has stopped being resized, and so on.
    </p>

    <p>
      At the end of the <b>wait</b> interval, the function will be called
      with the arguments that were passed <i>most recently</i> to the
      debounced function.
    </p>

    <p>
      Pass <tt>true</tt> for the <b>immediate</b> argument to cause
      <b>debounce</b> to trigger the function on the leading instead of the
      trailing edge of the <b>wait</b> interval. Useful in circumstances like
      preventing accidental double-clicks on a "submit" button from firing a
      second time.
    </p>

      <pre>
var lazyLayout = _.debounce(calculateLayout, 300);
$(window).resize(lazyLayout);
</pre>

    <p id="once">
      <b class="header">once</b><code>_.once(function)</code>
      <br/>
      Creates a version of the function that can only be called one time.
      Repeated calls to the modified function will have no effect, returning
      the value from the original call. Useful for initialization functions,
      instead of having to set a boolean flag and then check it later.
    </p>
      <pre>
var initialize = _.once(createApplication);
initialize();
initialize();
// Application is only created once.
</pre>

    <p id="after">
      <b class="header">after</b><code>_.after(count, function)</code>
      <br/>
      Creates a version of the function that will only be run after first
      being called <b>count</b> times. Useful for grouping asynchronous responses,
      where you want to be sure that all the async calls have finished, before
      proceeding.
    </p>
      <pre>
var renderNotes = _.after(notes.length, render);
_.each(notes, function(note) {
  note.asyncSave({success: renderNotes});
});
// renderNotes is run once, after all notes have saved.
</pre>

    <p id="before">
      <b class="header">before</b><code>_.before(count, function)</code>
      <br/>
      Creates a version of the function that can be called no more than
      <b>count</b> times. The result of the last function call is memoized and
      returned when <b>count</b> has been reached.
    </p>
      <pre>
var monthlyMeeting = _.before(3, askForRaise);
monthlyMeeting();
monthlyMeeting();
monthlyMeeting();
// the result of any subsequent calls is the same as the second call
</pre>

    <p id="wrap">
      <b class="header">wrap</b><code>_.wrap(function, wrapper)</code>
      <br/>
      Wraps the first <b>function</b> inside of the <b>wrapper</b> function,
      passing it as the first argument. This allows the <b>wrapper</b> to
      execute code before and after the <b>function</b> runs, adjust the arguments,
      and execute it conditionally.
    </p>
      <pre>
var hello = function(name) { return "hello: " + name; };
hello = _.wrap(hello, function(func) {
  return "before, " + func("moe") + ", after";
});
hello();
=&gt; 'before, hello: moe, after'
</pre>

    <p id="negate">
      <b class="header">negate</b><code>_.negate(predicate)</code>
      <br/>
      Returns a new negated version of the <b>predicate</b> function.
    </p>
      <pre>
var isFalsy = _.negate(Boolean);
_.find([-2, -1, 0, 1, 2], isFalsy);
=&gt; 0
</pre>

    <p id="compose">
      <b class="header">compose</b><code>_.compose(*functions)</code>
      <br/>
      Returns the composition of a list of <b>functions</b>, where each function
      consumes the return value of the function that follows. In math terms,
      composing the functions <i>f()</i>, <i>g()</i>, and <i>h()</i> produces
      <i>f(g(h()))</i>.
    </p>
      <pre>
var greet    = function(name){ return "hi: " + name; };
var exclaim  = function(statement){ return statement.toUpperCase() + "!"; };
var welcome = _.compose(greet, exclaim);
welcome('moe');
=&gt; 'hi: MOE!'
</pre>

    <h2 id="objects">Object Functions</h2>

    <p id="keys">
      <b class="header">keys</b><code>_.keys(object)</code>
      <br/>
      Retrieve all the names of the <b>object</b>'s own enumerable properties.
    </p>
      <pre>
_.keys({one: 1, two: 2, three: 3});
=&gt; ["one", "two", "three"]
</pre>

    <p id="allKeys">
      <b class="header">allKeys</b><code>_.allKeys(object)</code>
      <br/>
      Retrieve <i>all</i> the names of <b>object</b>'s own and inherited properties.
    </p>
      <pre>
function Stooge(name) {
  this.name = name;
}
Stooge.prototype.silly = true;
_.allKeys(new Stooge("Moe"));
=&gt; ["name", "silly"]
</pre>

    <p id="values">
      <b class="header">values</b><code>_.values(object)</code>
      <br/>
      Return all of the values of the <b>object</b>'s own properties.
    </p>
      <pre>
_.values({one: 1, two: 2, three: 3});
=&gt; [1, 2, 3]
</pre>

    <p id="mapObject">
      <b class="header">mapObject</b><code>_.mapObject(object, iteratee, [context])</code>
      <br/>
      Like <a href="#map">map</a>, but for objects. Transform the value
      of each property in turn.
    </p>
      <pre>
_.mapObject({start: 5, end: 12}, function(val, key) {
  return val + 5;
});
=&gt; {start: 10, end: 17}
</pre>

    <p id="pairs">
      <b class="header">pairs</b><code>_.pairs(object)</code>
      <br/>
      Convert an object into a list of <tt>[key, value]</tt> pairs.
    </p>
      <pre>
_.pairs({one: 1, two: 2, three: 3});
=&gt; [["one", 1], ["two", 2], ["three", 3]]
</pre>

    <p id="invert">
      <b class="header">invert</b><code>_.invert(object)</code>
      <br/>
      Returns a copy of the <b>object</b> where the keys have become the values
      and the values the keys. For this to work, all of your object's values
      should be unique and string serializable.
    </p>
      <pre>
_.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});
=&gt; {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};
</pre>

    <p id="create">
      <b class="header">create</b><code>_.create(prototype, props)</code>
      <br/>
      Creates a new object with the given prototype, optionally attaching
      <b>props</b> as <i>own</i> properties. Basically, <tt>Object.create</tt>,
      but without all of the property descriptor jazz.
    </p>
      <pre>
var moe = _.create(Stooge.prototype, {name: "Moe"});
</pre>

    <p id="object-functions">
      <b class="header">functions</b><code>_.functions(object)</code>
      <span class="alias">Alias: <b>methods</b></span>
      <br/>
      Returns a sorted list of the names of every method in an object &mdash;
      that is to say, the name of every function property of the object.
    </p>
      <pre>
_.functions(_);
=&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...
</pre>

    <p id="findKey">
      <b class="header">findKey</b><code>_.findKey(object, predicate, [context])</code>
      <br/>
      Similar to <a href="#findIndex"><tt>_.findIndex</tt></a> but for keys in objects.
      Returns the <i>key</i> where the <b>predicate</b> truth test
      passes or <i>undefined</i>.
    </p>

    <p id="extend">
      <b class="header">extend</b><code>_.extend(destination, *sources)</code>
      <br/>
      Copy all of the properties <strong>in</strong> the <b>source</b> objects over to the
      <b>destination</b> object, and return the <b>destination</b> object.
      It's in-order, so the last source will override properties of the same
      name in previous arguments.
    </p>
      <pre>
_.extend({name: 'moe'}, {age: 50});
=&gt; {name: 'moe', age: 50}
</pre>

    <p id="extendOwn">
      <b class="header">extendOwn</b><code>_.extendOwn(destination, *sources)</code>
      <span class="alias">Alias: <b>assign</b></span>
      <br/>
      Like <b>extend</b>, but only copies <i>own</i> properties over to the
      destination object.
    </p>

    <p id="pick">
      <b class="header">pick</b><code>_.pick(object, *keys)</code>
      <br/>
      Return a copy of the <b>object</b>, filtered to only have values for
      the whitelisted <b>keys</b> (or array of valid keys). Alternatively
      accepts a predicate indicating which keys to pick.
    </p>
      <pre>
_.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');
=&gt; {name: 'moe', age: 50}
_.pick({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {
  return _.isNumber(value);
});
=&gt; {age: 50}
</pre>

    <p id="omit">
      <b class="header">omit</b><code>_.omit(object, *keys)</code>
      <br/>
      Return a copy of the <b>object</b>, filtered to omit the blacklisted
      <b>keys</b> (or array of keys). Alternatively accepts a predicate
      indicating which keys to omit.
    </p>
      <pre>
_.omit({name: 'moe', age: 50, userid: 'moe1'}, 'userid');
=&gt; {name: 'moe', age: 50}
_.omit({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {
  return _.isNumber(value);
});
=&gt; {name: 'moe', userid: 'moe1'}
</pre>

    <p id="defaults">
      <b class="header">defaults</b><code>_.defaults(object, *defaults)</code>
      <br/>
      Fill in <tt>undefined</tt> properties in <b>object</b> with the first
      value present in the following list of <b>defaults</b> objects.
    </p>
      <pre>
var iceCream = {flavor: "chocolate"};
_.defaults(iceCream, {flavor: "vanilla", sprinkles: "lots"});
=&gt; {flavor: "chocolate", sprinkles: "lots"}
</pre>

    <p id="clone">
      <b class="header">clone</b><code>_.clone(object)</code>
      <br/>
      Create a shallow-copied clone of the provided <i>plain</i> <b>object</b>.
      Any nested objects or arrays will be copied by reference, not duplicated.
    </p>
      <pre>
_.clone({name: 'moe'});
=&gt; {name: 'moe'};
</pre>

    <p id="tap">
      <b class="header">tap</b><code>_.tap(object, interceptor)</code>
      <br/>
      Invokes <b>interceptor</b> with the <b>object</b>, and then returns <b>object</b>.
      The primary purpose of this method is to "tap into" a method chain, in order to perform operations on intermediate
      results within the chain.
    </p>
      <pre>
_.chain([1,2,3,200])
  .filter(function(num) { return num % 2 == 0; })
  .tap(alert)
  .map(function(num) { return num * num })
  .value();
=&gt; // [2, 200] (alerted)
=&gt; [4, 40000]
</pre>

    <p id="has">
      <b class="header">has</b><code>_.has(object, key)</code>
      <br/>
      Does the object contain the given key? Identical to
      <tt>object.hasOwnProperty(key)</tt>, but uses a safe reference to the
      <tt>hasOwnProperty</tt> function, in case it's been
      <a href="http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/">overridden accidentally</a>.
    </p>
      <pre>
_.has({a: 1, b: 2, c: 3}, "b");
=&gt; true
</pre>

    <p id="property">
      <b class="header">property</b><code>_.property(key)</code>
      <br/>
      Returns a function that will itself return the <tt>key</tt>
      property of any passed-in object.
    </p>
      <pre>
var stooge = {name: 'moe'};
'moe' === _.property('name')(stooge);
=&gt; true
</pre>

    <p id="propertyOf">
      <b class="header">propertyOf</b><code>_.propertyOf(object)</code>
      <br/>
      Inverse of <tt>_.property</tt>. Takes an object and returns a function
      which will return the value of a provided property.
    </p>
      <pre>
var stooge = {name: 'moe'};
_.propertyOf(stooge)('name');
=&gt; 'moe'</pre>

    <p id="matcher">
      <b class="header">matcher</b><code>_.matcher(attrs)</code>
      <span class="alias">Alias: <b>matches</b></span>
      <br/>
      Returns a predicate function that will tell you if a passed in object
      contains all of the key/value properties present in <b>attrs</b>.
    </p>
      <pre>
var ready = _.matcher({selected: true, visible: true});
var readyToGoList = _.filter(list, ready);</pre>

    <p id="isEqual">
      <b class="header">isEqual</b><code>_.isEqual(object, other)</code>
      <br/>
      Performs an optimized deep comparison between the two objects, to determine
      if they should be considered equal.
    </p>
      <pre>
var stooge = {name: 'moe', luckyNumbers: [13, 27, 34]};
var clone  = {name: 'moe', luckyNumbers: [13, 27, 34]};
stooge == clone;
=&gt; false
_.isEqual(stooge, clone);
=&gt; true
</pre>

    <p id="isMatch">
      <b class="header">isMatch</b><code>_.isMatch(object, properties)</code>
      <br/>
      Tells you if the keys and values in <b>properties</b> are contained
      in <b>object</b>.
    </p>
      <pre>
var stooge = {name: 'moe', age: 32};
_.isMatch(stooge, {age: 32});
=&gt; true
</pre>

    <p id="isEmpty">
      <b class="header">isEmpty</b><code>_.isEmpty(object)</code>
      <br/>
      Returns <i>true</i> if an enumerable <b>object</b> contains no
      values (no enumerable own-properties). For strings and array-like
      objects <tt>_.isEmpty</tt> checks if the length property is 0.
    </p>
      <pre>
_.isEmpty([1, 2, 3]);
=&gt; false
_.isEmpty({});
=&gt; true
</pre>

    <p id="isElement">
      <b class="header">isElement</b><code>_.isElement(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a DOM element.
    </p>
      <pre>
_.isElement(jQuery('body')[0]);
=&gt; true
</pre>

    <p id="isArray">
      <b class="header">isArray</b><code>_.isArray(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is an Array.
    </p>
      <pre>
(function(){ return _.isArray(arguments); })();
=&gt; false
_.isArray([1,2,3]);
=&gt; true
</pre>

    <p id="isObject">
      <b class="header">isObject</b><code>_.isObject(value)</code>
      <br/>
      Returns <i>true</i> if <b>value</b> is an Object. Note that JavaScript
      arrays and functions are objects, while (normal) strings and numbers are not.
    </p>
      <pre>
_.isObject({});
=&gt; true
_.isObject(1);
=&gt; false
</pre>

    <p id="isArguments">
      <b class="header">isArguments</b><code>_.isArguments(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is an Arguments object.
    </p>
      <pre>
(function(){ return _.isArguments(arguments); })(1, 2, 3);
=&gt; true
_.isArguments([1,2,3]);
=&gt; false
</pre>

    <p id="isFunction">
      <b class="header">isFunction</b><code>_.isFunction(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a Function.
    </p>
      <pre>
_.isFunction(alert);
=&gt; true
</pre>

    <p id="isString">
      <b class="header">isString</b><code>_.isString(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a String.
    </p>
      <pre>
_.isString("moe");
=&gt; true
</pre>

    <p id="isNumber">
      <b class="header">isNumber</b><code>_.isNumber(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a Number (including <tt>NaN</tt>).
    </p>
      <pre>
_.isNumber(8.4 * 5);
=&gt; true
</pre>

    <p id="isFinite">
      <b class="header">isFinite</b><code>_.isFinite(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a finite Number.
    </p>
      <pre>
_.isFinite(-101);
=&gt; true

_.isFinite(-Infinity);
=&gt; false
</pre>

    <p id="isBoolean">
      <b class="header">isBoolean</b><code>_.isBoolean(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is either <i>true</i> or <i>false</i>.
    </p>
      <pre>
_.isBoolean(null);
=&gt; false
</pre>

    <p id="isDate">
      <b class="header">isDate</b><code>_.isDate(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a Date.
    </p>
      <pre>
_.isDate(new Date());
=&gt; true
</pre>

    <p id="isRegExp">
      <b class="header">isRegExp</b><code>_.isRegExp(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a RegExp.
    </p>
      <pre>
_.isRegExp(/moe/);
=&gt; true
</pre>

    <p id="isError">
      <b class="header">isError</b><code>_.isError(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> inherits from an Error.
    </p>
      <pre>
try {
  throw new TypeError("Example");
} catch (o_O) {
  _.isError(o_O);
}
=&gt; true
</pre>

    <p id="isSymbol">
      <b class="header">isSymbol</b><code>_.isSymbol(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is a Symbol.
    </p>
      <pre>
_.isSymbol(Symbol());
=&gt; true
</pre>

    <p id="isNaN">
      <b class="header">isNaN</b><code>_.isNaN(object)</code>
      <br/>
      Returns <i>true</i> if <b>object</b> is <i>NaN</i>.<br/> Note: this is not
      the same as the native <b>isNaN</b> function, which will also return
      true for many other not-number values, such as <tt>undefined</tt>.
    </p>
      <pre>
_.isNaN(NaN);
=&gt; true
isNaN(undefined);
=&gt; true
_.isNaN(undefined);
=&gt; false
</pre>

    <p id="isNull">
      <b class="header">isNull</b><code>_.isNull(object)</code>
      <br/>
      Returns <i>true</i> if the value of <b>object</b> is <i>null</i>.
    </p>
      <pre>
_.isNull(null);
=&gt; true
_.isNull(undefined);
=&gt; false
</pre>

    <p id="isUndefined">
      <b class="header">isUndefined</b><code>_.isUndefined(value)</code>
      <br/>
      Returns <i>true</i> if <b>value</b> is <i>undefined</i>.
    </p>
      <pre>
_.isUndefined(window.missingVariable);
=&gt; true
</pre>
    <ng-include src="'sections/time/content.html'"></ng-include>

  </div>

</div>

<!-- Include Underscore, so you can play with it in the console. -->
<script type="text/javascript" src="underscore-master/underscore.js"></script>
<script type="text/javascript" src="docs/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.5.5/angular.js"></script>
</body>
</html>
